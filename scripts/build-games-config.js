#!/usr/bin/env node

/**
 * Script de build pour dÃ©couvrir automatiquement tous les jeux disponibles
 * GÃ©nÃ¨re un fichier statique avec la configuration des jeux
 * S'exÃ©cute au moment du build, pas au runtime
 * Supporte le mode watch pour le dÃ©veloppement
 */

const fs = require('fs');
const path = require('path');

const GAMES_DIR = path.join(__dirname, '../src/games');
const OUTPUT_FILE = path.join(
  __dirname,
  '../src/lib/games-config.generated.ts'
);

function discoverGames() {
  const games = [];

  if (!fs.existsSync(GAMES_DIR)) {
    console.error('Games directory not found:', GAMES_DIR);
    return games;
  }

  const entries = fs.readdirSync(GAMES_DIR, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory()) {
      const gameId = entry.name;
      const gamePath = path.join(GAMES_DIR, gameId);

      // VÃ©rifier que le jeu a les fichiers requis
      const hasIndex = fs.existsSync(path.join(gamePath, 'index.tsx'));
      const hasRules = fs.existsSync(path.join(gamePath, 'rules.tsx'));
      const hasConfig = fs.existsSync(path.join(gamePath, 'config.ts'));

      if (hasIndex && hasRules && hasConfig) {
        try {
          // Lire le fichier de config pour extraire les mÃ©tadonnÃ©es
          const configPath = path.join(gamePath, 'config.ts');
          const configContent = fs.readFileSync(configPath, 'utf-8');

          // Extraire le nom de la variable d'export
          const metadataMatch = configContent.match(
            /export const (\w+_METADATA)/
          );
          if (!metadataMatch) {
            console.warn(`No metadata export found in ${gameId}/config.ts`);
            continue;
          }

          const metadataVarName = metadataMatch[1];

          games.push({
            id: gameId,
            metadataVarName,
            hasIndex,
            hasRules,
            hasConfig,
          });

          console.log(`âœ… Found game: ${gameId}`);
        } catch (error) {
          console.error(`Error processing ${gameId}:`, error);
        }
      } else {
        console.warn(`âš ï¸  Incomplete game: ${gameId}`, {
          hasIndex,
          hasRules,
          hasConfig,
        });
      }
    }
  }

  return games;
}

function generateGamesConfig(games) {
  const imports = games
    .map(
      game =>
        `import { ${game.metadataVarName} } from '../games/${game.id}/config';`
    )
    .join('\n');

  const gameEntries = games
    .map(
      game =>
        `  '${game.id}': {
    component: () => import('../games/${game.id}'),
    metadata: ${game.metadataVarName},
  },`
    )
    .join('\n');

  const content = `// Auto-generated games configuration
// Generated by scripts/build-games-config.js
// Do not edit manually

${imports}

import { GameComponent, GameMetadata } from './games';

export const GAMES_CONFIG: Record<
  string,
  {
    component: () => Promise<{ default: GameComponent }>;
    metadata: GameMetadata;
  }
> = {
${gameEntries}
};

export const DISCOVERED_GAMES = [${games.map(g => `'${g.id}'`).join(', ')}] as const;

export type DiscoveredGameId = (typeof DISCOVERED_GAMES)[number];
`;

  fs.writeFileSync(OUTPUT_FILE, content);
  console.log(`ðŸ“ Generated games config: ${OUTPUT_FILE}`);
}

function main() {
  const isWatchMode = process.argv.includes('--watch');

  if (isWatchMode) {
    console.log('ðŸ‘€ Watching games directory for changes...');
    console.log('Press Ctrl+C to stop watching');
  } else {
    console.log('ðŸ” Discovering games for build...');
  }

  const games = discoverGames();

  if (games.length === 0) {
    console.error('âŒ No games found!');
    if (!isWatchMode) process.exit(1);
    return;
  }

  console.log(
    `ðŸŽ® Found ${games.length} games:`,
    games.map(g => g.id).join(', ')
  );

  generateGamesConfig(games);
  console.log('âœ… Games configuration generated!');

  if (isWatchMode) {
    console.log('ðŸ”„ Watching for changes...');
  }
}

if (require.main === module) {
  main();
}

module.exports = { discoverGames, generateGamesConfig };
